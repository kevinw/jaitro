size_t :: u64;

my_window: Window_Type;
window_width  : s32 = 1920;
window_height : s32 = 1080;

image_test: Simp.Texture;

screenshot_index := 0;

Key_Code :: Input.Key_Code;

g_scale :: 3.0;

Keymap :: struct {
    k: Key_Code;
    rk: u32;
}

current_context: *#Context;

// Call this from #c_call core callback functions to be able to access the context.
Set_Context :: () #expand {
    assert(current_context == null);
    `current_context = *context;
    `defer { current_context = null; }
}


// Call this from Jai code invoking core functions, so that any of the callbacks have access to the context. We accomplish this by setting the current_context global variable to the current context.
Push_Context :: () #expand {
    if current_context == null {
        push_context {
            Debug.breakpoint();
            ptr: *s8 = null;
            ptr.* = 0;
        }
    }

    `push_context,defer_pop current_context;
}

Exec_State :: struct {
    video: struct {
        tex_id: u32;
        pitch: u32;
        tex_w: s32;
        tex_h: s32;
        clip_w: u32;
        clip_h: u32;

        pixfmt: u32;
        pixtype: u32;
        bpp: u32;

        window_width, window_height: s32;
    };

    joy: [retro.RETRO_DEVICE_ID_JOYPAD_R3 + 1]s16;
    binds: [11]Keymap;

    frontend_did_update_core_variable: bool = false;

    audio: struct {
        mute := false;
        did_init_with_sample_rate: float64 = -1;
    };
}

#add_context ex: Exec_State;

// TODO: This and Core_Funcs could be generated by the bindings generator script.
core_function_names : []string = .[
    "init", 
    "deinit", 
    "api_version", 
    "get_system_info", 
    "get_system_av_info",
    "set_controller_port_device",
    "reset",
    "run",
    "load_game",
    "unload_game",
    "serialize_size",
    "serialize",
    "unserialize",

    "set_environment",
    "set_video_refresh",
    "set_input_poll",
    "set_input_state",
    "set_audio_sample",
    "set_audio_sample_batch",
];

Core_Funcs :: struct {
    #insert -> string {
        sb: String_Builder;
        for core_function_names append(*sb, tprint("%: type_of(retro.%);\n", it, it));
        return builder_to_string(*sb);
    }
}

Core :: struct {
    dll: Library;
    using funcs: Core_Funcs;
}

load_sym :: (library: Library, sym_name: *u8) -> *void {
    sym := get_symbol(library, sym_name);
    assert(sym != null, tprint("couldn't get symbol '%'", to_string(sym_name)));
    return sym;
}

load_core :: (core: *Core) -> bool {

    assert(core != null);
    using core;

    dll = load("run_tree/cores/mesen_libretro.dylib");
    //dll = load("run_tree/cores/mesen_libretro_debug.dylib");
    if !dll return false;

    #insert -> string {
        sb: String_Builder;
        fmt_str :: "% = load_sym(dll, \"retro_%\");";
        for core_function_names append(*sb, tprint(fmt_str, it, it));
        return builder_to_string(*sb);
    }

    Set_Context();
    assert(api_version() == 1);

    sys_info: retro.system_info;
    get_system_info(*sys_info);
    {
        using sys_info;
        print("% % - %\n", to_string(library_name), to_string(library_version), to_string(valid_extensions));
    }

    set_environment(core_environment);
    init();
    set_video_refresh(core_video_refresh);
    set_input_poll(core_input_poll);
    set_input_state(core_input_state);
    set_audio_sample(core_audio_sample);
    set_audio_sample_batch(core_audio_sample_batch);

    return true;
}

core_video_refresh :: (data: *void, width: u32, height: u32, pitch: size_t) #c_call {
    if data == null return;
    Push_Context();
    video_refresh(data, width, height, cast(u32)pitch);
}

video_refresh :: (data: *void, width: u32, height: u32, pitch: u32) {
    using context.ex;
    if video.clip_w != width || video.clip_h != height {
        video.clip_w = width;
        video.clip_h = height;
    }

    glBindTexture(GL_TEXTURE_2D, video.tex_id);
    if pitch != video.pitch {
        video.pitch = pitch;
        glPixelStorei(GL_UNPACK_ROW_LENGTH, cast(s32)(pitch / video.bpp));
    }

    if data {
        glTexSubImage2D(GL_TEXTURE_2D, 0, 0, 0, width, height, video.pixtype, video.pixfmt, data);
    }
}

core_input_poll :: () #c_call {
    Push_Context();
    using context.ex;
    for binds {
        joy[it.rk] = cast(s16)(ifx Input.input_button_states[it.k] & .DOWN 1 else 0);
    }
}

core_input_state :: (port: u32, device: u32, index: u32, id: u32) -> s16 #c_call {
    Push_Context();
    using context.ex;

    if port || index || device != retro.RETRO_DEVICE_JOYPAD || id >= joy.count {
        //print("unknown core_input_state query %, %, %, %\n", port, device, index, id);
        return 0;
    }

    return joy[id];
}

core_audio_sample :: (left: s16, right: s16) #c_call {
    Push_Context();
    print("TODO: audio_sample %, %\n", left, right);
}


core_audio_sample_batch :: (data: *s16, frames: size_t) -> size_t #c_call {
    Push_Context();
    using context.ex;
    if !audio.mute {
        flt_buf: [4096]float;
        S16_MAX :: 32767;
        for i: 0..frames*2 #no_abc {
            flt_buf[i] = cast(float)data[i] / cast(float)S16_MAX;
        }
        
        saudio.push(flt_buf.data, cast(s32)frames);
    }
    return frames;
}

video_set_pixel_format :: (format: retro.pixel_format) -> bool {
    Push_Context();
    using context.ex;

    if video.tex_id != 0 {
        log_error("video_set_pixel_format called after video has already been initialized");
        return false;
    }

    if format == {
        case ._0RGB1555;
            video.pixfmt = GL_UNSIGNED_SHORT_5_5_5_1;
            video.pixtype = GL_BGRA;
            video.bpp = size_of(u16);
        case .XRGB8888;
            video.pixfmt = GL_UNSIGNED_INT_8_8_8_8_REV;
            video.pixtype = GL_BGRA;
            video.bpp = size_of(u32);
        case .RGB565;
            video.pixfmt = GL_UNSIGNED_SHORT_5_6_5;
            video.pixtype = GL_RGB;
            video.bpp = size_of(u16);
        case;
            log_error("unsupported pixel format %", format);
            return false;
    }

    return true;
}

core_environment :: (cmd: u32, data: *void) -> bool #c_call {
    using retro;
    if cmd == {
        case RETRO_ENVIRONMENT_GET_LOG_INTERFACE;
            (cast(*retro.log_callback)data).log = core_log;
            core_log(retro.log_level.DEBUG, "core_log test %d\n", 42);

        case RETRO_ENVIRONMENT_GET_CAN_DUPE;
            (cast(*bool)data).* = true;

        case RETRO_ENVIRONMENT_SET_PIXEL_FORMAT;
            Push_Context();
            fmt := (cast(*retro.pixel_format)data).*;
            if fmt > retro.pixel_format.RGB565 {
                print("ERROR: unsupported pixel format %\n", fmt);
                return false;
            }

            return video_set_pixel_format(fmt);

        case RETRO_ENVIRONMENT_GET_SYSTEM_DIRECTORY; #through;
        case RETRO_ENVIRONMENT_GET_SAVE_DIRECTORY;
            (cast(**u8)data).* = ".";

        case RETRO_ENVIRONMENT_GET_CORE_OPTIONS_VERSION;
            (cast(*u32)data).* = 1;

        case RETRO_ENVIRONMENT_GET_LANGUAGE;
            (cast(*retro.language)data).* = retro.language.ENGLISH;

        case RETRO_ENVIRONMENT_SET_CONTROLLER_INFO;
            controller_info := cast(*retro.controller_info)data;
            Push_Context();
            while controller_info.types != null {
                //print("controller info: %\n", controller_info.*);

                controller_desc := controller_info.types;
                while controller_desc.id != 0 {
                    //print("  desc: %\n", to_string(controller_desc.desc));
                    //print("  id: %\n", controller_desc.id);
                    controller_desc += 1;
                }

                controller_info += 1;
            }

        case RETRO_ENVIRONMENT_SET_CONTENT_INFO_OVERRIDE;
            return false;

        case RETRO_ENVIRONMENT_GET_INPUT_BITMASKS;
            return false;

        case RETRO_ENVIRONMENT_SET_CORE_OPTIONS_INTL;
            return false;

        case RETRO_ENVIRONMENT_GET_VARIABLE_UPDATE;
            // Queries whether at least one core option was updated by the frontend since the last call to \ref RETRO_ENVIRONMENT_GET_VARIABLE. This typically means that the user opened the core options menu and made some changes.
            Push_Context();
            using context.ex;
            (cast(*bool)data).* = frontend_did_update_core_variable;
            frontend_did_update_core_variable = false;
            return true;

        case RETRO_ENVIRONMENT_GET_VARIABLE;
            variable := cast(*retro.variable)data;
            if !variable { return false; }
            Push_Context();
            print(": get_variable % - % (ignoring)\n", to_string(variable.key), to_string(variable.value));
            return false;

        case RETRO_ENVIRONMENT_SET_GEOMETRY;
            geometry := cast(*retro.game_geometry)data;
            if !geometry { return false; }
            Push_Context();
            // TODO: actually set the geometry
            print("TODO: set_geometry %, %, %, %, %\n", geometry.base_width, geometry.base_height, geometry.max_width, geometry.max_height, geometry.aspect_ratio);
            return false;

        case RETRO_ENVIRONMENT_GET_GAME_INFO_EXT;
            // we could provide more info to the core here....
            e := cast(*retro.game_info_ext)data;
            if !e { return false; }
            return false;
        
        case;
            Push_Context();
            print("Unhandled env %\n", cmd);
            return false;
    }

    return true;
}

take_screenshot :: () {
    screenshot_index += 1;
    async_read := Simp.pixel_read_begin(null, .RGBA8); // TODO: this can be async. see Simp example in Jai
    bitmap     := Simp.pixel_read_end(async_read);
    filename := tprint("screenshot%.png\0", screenshot_index);
    #import "stb_image_write";
    stbi_write_png(filename.data, bitmap.width, bitmap.height, 4, bitmap.data.data, xx (bitmap.width * Simp.get_image_bytes_per_texel(bitmap.format)));  // Hardcoded to 4 channels because we know we requested .BGRA8 above.
    Simp.deinit(*bitmap);
}

do_load_game :: (core: *Core, path: string) -> bool {
    // Check if file exists
    if !file_exists(path) {
        log_error("file % does not exist", path);
        return false;
    }

    if ends_with(path, ".zip") {
        // Unzip the file

        #import "Compiler";
        #import "File";

        basename, _path := get_basename_and_path(path);

        output_dir := tprint(".tmp/%", basename);
        make_directory_if_it_does_not_exist(output_dir, true);

        print("Unzipping...");
        run_command("unzip", "-u", "-qq", path, "-d", output_dir);
        print("done\n");

        file_path := tprint("%/%.nes", output_dir, basename); // TODO: actually list the contents of the zip and find the ROM
        return do_load_game(core, file_path);

    }

    if ends_with(path, ".nes") {
        print("Loading NES game %\n", path);

        game_info: retro.game_info = .{
            path=temp_c_string(path)
        };

        {
            using context.ex;
            using retro;
            binds[0]  = .{cast(Key_Code)(#char "X"), RETRO_DEVICE_ID_JOYPAD_A};
            binds[1]  = .{cast(Key_Code)(#char "Z"), RETRO_DEVICE_ID_JOYPAD_B};
            binds[2]  = .{cast(Key_Code)(#char "A"), RETRO_DEVICE_ID_JOYPAD_Y};
            binds[3]  = .{cast(Key_Code)(#char "S"), RETRO_DEVICE_ID_JOYPAD_X};
            binds[4]  = .{.ARROW_UP, RETRO_DEVICE_ID_JOYPAD_UP};
            binds[5]  = .{.ARROW_DOWN, RETRO_DEVICE_ID_JOYPAD_DOWN};
            binds[6]  = .{.ARROW_LEFT, RETRO_DEVICE_ID_JOYPAD_LEFT};
            binds[7]  = .{.ARROW_RIGHT, RETRO_DEVICE_ID_JOYPAD_RIGHT};
            binds[8]  = .{.ENTER, RETRO_DEVICE_ID_JOYPAD_START};
            binds[9]  = .{.BACKSPACE, RETRO_DEVICE_ID_JOYPAD_SELECT};
        }

        Set_Context();
        did_load := core.load_game(*game_info);
        if !did_load {
            log_error("core failed to load game '%'", path);
            return false;
        }

        av: retro.system_av_info;
        core.get_system_av_info(*av);

        // init video
        video_configure(*av.geometry);

        // init audio
        using context.ex;
        if !audio.mute && av.timing.sample_rate != audio.did_init_with_sample_rate {
            if audio.did_init_with_sample_rate != -1 {
                print("AUDIO shutting down\n");
                saudio.shutdown();
            }

            saudio_desc: saudio.Desc;
            saudio_desc.num_channels = 2;
            saudio_desc.sample_rate = cast(s32)av.timing.sample_rate;

            print("initing audio with sample rate % and % channels\n", saudio_desc.sample_rate, saudio_desc.num_channels);
            saudio.setup(*saudio_desc);

            assert(saudio.isvalid()); // TODO: don't hard crash if we don't have a sound card....

            audio.did_init_with_sample_rate = av.timing.sample_rate;
        }
    }

    return true;
}

resize_to_aspect :: (ratio: float64, sw: s32, sh: s32, dw: *s32, dh: *s32) {
	<<dw = sw;
	<<dh = sh;

	if ratio <= 0
		ratio = cast(float64)sw / sh;

	if cast(float)sw / sh < 1 {
		dw.* = cast(s32)(dh.* * ratio);
    } else {
		dh.* = cast(s32)(dw.* / ratio);
    }
}

video_configure :: (geom: *retro.game_geometry) -> bool {
    using context.ex;
    assert(glGetError() == GL_NO_ERROR);

    nwidth: s32;
    nheight: s32;

	resize_to_aspect(geom.aspect_ratio, cast(s32)geom.base_width * 1, cast(s32)geom.base_height * 1, *nwidth, *nheight);
    assert(glGetError() == GL_NO_ERROR);

	nwidth = cast(s32)(nwidth * g_scale);
	nheight = cast(s32)(nheight * g_scale);


    video.window_width = cast(s32)geom.max_width;
    video.window_height = cast(s32)geom.max_height;

    if video.tex_id {
        glDeleteTextures(1, *video.tex_id);
        video.tex_id = 0;
    }

    if !video.pixfmt {
        video.pixfmt = GL_UNSIGNED_SHORT_5_5_5_1;
    }

    assert(glGetError() == GL_NO_ERROR);
    glGenTextures(1, *video.tex_id);
    assert(glGetError() == GL_NO_ERROR);

    if !video.tex_id {
        log_error("failed to create texture");
        return false;
    }

    glBindTexture(GL_TEXTURE_2D, video.tex_id);
    video.pitch = geom.base_width * video.bpp;

    glBindTexture(GL_TEXTURE_2D, video.tex_id);

    //	glPixelStorei(GL_UNPACK_ALIGNMENT, s_video.pixfmt == GL_UNSIGNED_INT_8_8_8_8_REV ? 4 : 2);
    //	glPixelStorei(GL_UNPACK_ROW_LENGTH, s_video.pitch / s_video.bpp);

	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);

    //print("tex image created with max_width % and max_height %\n", geom.max_width, geom.max_height);
    //print("clip_w/h is % %\n", geom.base_width, geom.base_height);

	glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA8, geom.max_width, geom.max_height, 0,
			video.pixtype, video.pixfmt, null);

	glBindTexture(GL_TEXTURE_2D, 0);

	video.tex_w = cast(s32)geom.max_width;
	video.tex_h = cast(s32)geom.max_height;
	video.clip_w = geom.base_width;
	video.clip_h = geom.base_height;


    assert(glGetError() == GL_NO_ERROR);

    return true;
}

advance_frame :: (core: *Core) {
    Set_Context();
    core.run();
}

main :: () {
    #if OS == .WINDOWS {
        Windows :: #import "Windows";
        Windows.SetProcessDPIAware();

        // Windows is very bad at thread-switching by default unless you do this. Sad.
        Windows.timeBeginPeriod(1);
    }

    WANTED_MSAA :: 0;
    // On Linux, we need to pass the MSAA value to create_window
    my_window = create_window(window_width, window_height, "jaitro", wanted_msaa = WANTED_MSAA);

    // On other operating systems, the MSAA value needs to be passed to *_create_context, so we
    // need to have an extra step here if you want MSAA.
    msaa := Simp.prepare_window(my_window, wanted_msaa = WANTED_MSAA);
    log("Wanted MSAA: %\nChosen MSAA: %", WANTED_MSAA, msaa);

    // Actual render size in pixels can be different from the window dimensions we specified above (for example on high-resolution displays on macOS/iOS).
    window_width, window_height = Simp.get_render_dimensions(my_window);

    Simp.set_render_target(my_window, .LEFT_HANDED);

    ////////


    core: Core;
    did_load := load_core(*core);
    if !did_load {
        print("Error loading core.\n");
        exit(1);
    }
    defer core.deinit();
    do_load_game(*core, "run_tree/roms/Bonk's Adventure.zip");


    ///////

    my_init_fonts();
    success := Simp.texture_load_from_file(*image_test, "image_test.jpg");
    assert(success);

    quit := false;
    want_screenshot := false;
    while !quit {
        Input.update_window_events();

        for Input.get_window_resizes() {
            Simp.update_window(it.window);  // Simp will do nothing if it doesn't care about this window.

            if it.window == my_window {
                should_reinit := (it.width != window_width) || (it.height != window_height);

                window_width  = it.width;
                window_height = it.height;

                if should_reinit my_init_fonts();  // Resize the font for the new window size.
            }
        }

        for Input.events_this_frame {
            if it.type == .QUIT then quit = true;

            if it.type == {
              case .KEYBOARD;
                if it.key_pressed && it.key_code == .ESCAPE {
                    quit = true;
                }

                if it.key_pressed && it.key_code == #char " " {  // Press spacebar to take a screenshot.
                    want_screenshot = true;
                }
            }
        }

        advance_frame(*core);
        draw_one_frame();

        if want_screenshot {
            take_screenshot();
            want_screenshot = false;
        }

        sleep_milliseconds(10);
        reset_temporary_storage();
    }
}

draw_one_frame :: () {
    Simp.clear_render_target(.15, .08, .08, 1);

    Simp.set_shader_for_color();

    time := seconds_since_init();

    // This is our own code to set up a rotating square:
    {
        b := cast(float)window_height / 10;
        p: Vector2;
        p.x = cast(float)(window_width  / 2);
        p.y = cast(float)(window_height / 2);

        theta := cast(float) fmod_cycling(time, TAU);

        ct := cos(theta);
        st := sin(theta);

        w := Vector2.{b*ct, b*st};
        h := Vector2.{b*st, -b*ct};

        p0 := p - w - h;
        p1 := p + w - h;
        p2 := p + w + h;
        p3 := p - w + h;

        a :: 1.0;
        c0 := Vector4.{1, 0, 0, a};
        c1 := Vector4.{0, 1, 0, a};
        c2 := Vector4.{0, 0, 1, a};
        c3 := Vector4.{1, 1, 1, a};

        Simp.immediate_quad(p0, p1, p2, p3, c0, c1, c2, c3);
    }

    // Draw some text.
    {
        // Do a bunch of wacky math to figure out the text color.
        theta := cast(float) fmod_cycling(time*3, TAU);

        color: Vector4;
        color.x = cos(theta)*.5+.5;
        Clamp(*color.x, 0, 1);
        color.y = 1;
        color.z = sin(theta)*-.5+.5;
        Clamp(*color.z, 0, 1);
        color.w = 1;

        // Now, to draw the text:
        text := "jaitro";

        // We could just call Simp.draw_text to draw text! But we want to know the width
        // so that we can center the text, and to find the width, we have to do all the
        // text layout. So it makes sense just to draw the prepared text after that,
        // so there's a special routine, "draw_prepared_text", that draws the thing
        // you just prepared and got the width of.

        text_width := Simp.prepare_text(my_font, text);

        text_x := (window_width - text_width) / 2;
        text_y := window_height/2 + my_font.character_height/4;

        Simp.draw_prepared_text(my_font, text_x, text_y, color);
    }


    if image_test.width && image_test.height {
        // Draw the texture test, to make sure
        // it comes out right-side-up.

        Simp.set_shader_for_images(*image_test);
        Simp.immediate_begin();

        w := window_height/8.0;
        y0 := cast(float) window_height;

        Simp.immediate_quad(.{0, y0-w}, .{w, y0-w}, .{w, y0}, .{0, y0});
        Simp.immediate_flush();
    }

    {
        using context.ex;
        if video.tex_id {
            tex: Simp.Texture;
            tex.width = video.tex_w;
            tex.height = video.tex_h;
            tex.format = .RGBA8;
            tex.gl_handle = video.tex_id;
            Simp.set_shader_for_images(*tex);
            Simp.immediate_begin();
            w := window_height/4.0;
            y0 := cast(float) window_height;
            x := 200.0;

            Simp.immediate_quad(.{x, y0-w}, .{x+w, y0-w}, .{x+w, y0}, .{x, y0});
            Simp.immediate_flush();
        }
    }

    Simp.swap_buffers(my_window);
}

my_init_fonts :: () {
    // So that we can load our font, set to path of running executable.
    // @Incomplete: Pack a default font into Simp.

    if !working_directory_set {
        path := path_strip_filename(get_path_of_running_executable());
        set_working_directory(path);
        working_directory_set = true;
    }

    pixel_height := window_height / 24;

    // @Cleanup: Don't have path + name be separate.
    my_font = Simp.get_font_at_size(".", "OpenSans-BoldItalic.ttf", pixel_height);
    assert(my_font != null);
}

working_directory_set := false;

my_font: *Simp.Dynamic_Font;

Simp  :: #import "Simp";
Input :: #import "Input";

#import "Window_Creation";

#import "Basic";
#import "Math";
#import "System";  // For get_path_of_running_executable. @Cleanup.
#import "String";  // For path_strip_filename. @Cleanup.
retro :: #import,file "./libretro.jai";
#import,file "./Dyn_Lib.jai";
#import "File_Utilities";
#import "Process";
Debug :: #import "Debug";
#import "GL";
saudio :: #import,file "./Sokol_Audio/module.jai";

// workaround for jai not supporting varargs in #c_call yet. build with "pushd jaitro_c && ./build && popd"
jaitro_c :: #library,no_dll "jaitro_c/jaitro_c";
core_log :: (level: retro.log_level, fmt: *u8, args: ..Any) #foreign jaitro_c;

#run {
    #if OS == .WINDOWS {
        WR :: #import "Windows_Resources";
        WR.disable_runtime_console();
    }
}
